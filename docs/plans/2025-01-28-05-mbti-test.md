# é˜¶æ®µäº”ï¼šMBTI æµ‹è¯• Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** å®ç°ç‹—ç‹— MBTI æ€§æ ¼æµ‹è¯•åŠŸèƒ½

**Duration:** 2-3å¤©

**Tech Stack:** FastAPI, React Native, React Hook Form

**Reference:** `docs/designs/2025-01-28-doggy-meetup-design.md` ç¬¬2.1èŠ‚

---

## Task 1: åç«¯ MBTI æµ‹è¯•æ•°æ®

**Files:**
- Create: `server/app/data/mbti_questions.json` - æµ‹è¯•é¢˜åº“
- Create: `server/app/data/mbti_results.json` - ç»“æœè§£é‡Š
- Create: `server/app/services/mbti_service.py` - MBTI è®¡ç®—æœåŠ¡

**Step 1: åˆ›å»ºæµ‹è¯•é¢˜åº“**

```json
// server/app/data/mbti_questions.json
{
  "questions": [
    {
      "id": 1,
      "dimension": "E",
      "question": "é‡åˆ°æ–°ç‹—æ—¶ï¼Œä½ å®¶ç‹—ç‹—ä¼šï¼Ÿ",
      "options": [
        { "text": "ä¸»åŠ¨å‡‘ä¸Šå»é—»", "value": "E" },
        { "text": "èº²åœ¨ä½ èº«å", "value": "I" }
      ]
    },
    {
      "id": 2,
      "dimension": "E",
      "question": "åœ¨å…¬å›­é‡Œï¼Œä½ å®¶ç‹—ç‹—æ›´å–œæ¬¢ï¼Ÿ",
      "options": [
        { "text": "å’Œæ¯åªç‹—æ‰“æ‹›å‘¼", "value": "E" },
        { "text": "åªè·Ÿç€ä½ èµ°", "value": "I" }
      ]
    },
    {
      "id": 3,
      "dimension": "S",
      "question": "ç©ç©å…·æ—¶ï¼Œæ›´å–œæ¬¢ï¼Ÿ",
      "options": [
        { "text": "æ‰”çƒä½ æ¡å›æ¥", "value": "S" },
        { "text": "è¿½é€æ‰“é—¹", "value": "N" }
      ]
    },
    {
      "id": 4,
      "dimension": "S",
      "question": "å¯¹å¾…é£Ÿç‰©ï¼Œä½ å®¶ç‹—ç‹—æ˜¯ï¼Ÿ",
      "options": [
        { "text": "ä¸“æ³¨äºçœ¼å‰ç¾é£Ÿ", "value": "S" },
        { "text": "å¯¹æ–°é²œå¥½å¥‡", "value": "N" }
      ]
    },
    {
      "id": 5,
      "dimension": "T",
      "question": "ä½ ä¸åœ¨å®¶æ—¶ï¼Œç‹—ç‹—ä¼šï¼Ÿ",
      "options": [
        { "text": "å®‰é™ç­‰å¾…", "value": "T" },
        { "text": "åµé—¹æ‹†å®¶", "value": "F" }
      ]
    },
    {
      "id": 6,
      "dimension": "T",
      "question": "çŠ¯é”™è¢«è®­æ–¥æ—¶ï¼Œç‹—ç‹—çš„ååº”æ˜¯ï¼Ÿ",
      "options": [
        { "text": "å†·é™è§‚å¯Ÿ", "value": "T" },
        { "text": "å§”å±ˆæ±‚é¥¶", "value": "F" }
      ]
    },
    {
      "id": 7,
      "dimension": "J",
      "question": "æ•£æ­¥è·¯çº¿è¢«æ‰“ä¹±ï¼Œç‹—ç‹—ä¼šï¼Ÿ",
      "options": [
        { "text": "ç„¦è™‘ä¸å®‰", "value": "J" },
        { "text": "éšé‡è€Œå®‰", "value": "P" }
      ]
    },
    {
      "id": 8,
      "dimension": "J",
      "question": "åƒé¥­æ—¶é—´ï¼Œä½ å®¶ç‹—ç‹—æ˜¯ï¼Ÿ",
      "options": [
        { "text": "å›ºå®šæ—¶é—´æé†’", "value": "J" },
        { "text": "ä»€ä¹ˆæ—¶å€™éƒ½è¡Œ", "value": "P" }
      ]
    }
    // ... æ€»å…±20é¢˜ï¼Œæ¯ç»´åº¦5é¢˜
  ]
}
```

**Step 2: åˆ›å»ºç»“æœè§£é‡Š**

```json
// server/app/data/mbti_results.json
{
  "types": {
    "ESTJ": {
      "name": "å®ˆæŠ¤é˜Ÿé•¿",
      "description": "å¯é ã€è´Ÿè´£ä»»çš„ç‹—ç‹—ï¼Œå–œæ¬¢è§„å¾‹å’Œç§©åºï¼Œæ˜¯å¤©ç”Ÿçš„é¢†å¯¼è€…ã€‚",
      "tags": ["å¯é ", "æœ‰è´£ä»»å¿ƒ", "å®ˆè§„çŸ©"],
      "compatibility": ["ESFJ", "ISTJ"]
    },
    "ESFJ": {
      "name": "ç¤¾äº¤è´è¶",
      "description": "å‹å–„ã€çƒ­æƒ…çš„ç‹—ç‹—ï¼Œå–œæ¬¢å’Œæ‰€æœ‰äººäº¤æœ‹å‹ï¼Œæ˜¯å¤©ç”Ÿçš„ç¤¾äº¤å®¶ã€‚",
      "tags": ["å‹å–„", "çƒ­æƒ…", "çˆ±ç¤¾äº¤"],
      "compatibility": ["ESTJ", "ISFJ"]
    },
    "ISTJ": {
      "name": "å¿ è¯šå«å£«",
      "description": "å®‰é™ã€å¿ è¯šçš„ç‹—ç‹—ï¼Œå¯¹ä¸»äººæå…¶å¿ å¿ƒï¼Œæ˜¯å¯é çš„å®ˆæŠ¤è€…ã€‚",
      "tags": ["å¿ è¯š", "å®‰é™", "å¯é "],
      "compatibility": ["ESTJ", "ISFJ"]
    },
    "ISFJ": {
      "name": "æ¸©æŸ”å®ˆæŠ¤",
      "description": "æ¸©å’Œã€ä½“è´´çš„ç‹—ç‹—ï¼Œå¯¹å®¶äººçš„æƒ…æ„Ÿå˜åŒ–éå¸¸æ•æ„Ÿã€‚",
      "tags": ["æ¸©å’Œ", "ä½“è´´", "æ•æ„Ÿ"],
      "compatibility": ["ESFJ", "ISTJ"]
    },
    "ESTP": {
      "name": "æ´»åŠ›æ¢é™©å®¶",
      "description": "ç²¾åŠ›å……æ²›ã€å–œæ¬¢å†’é™©çš„ç‹—ç‹—ï¼Œæ€»æ˜¯å‡†å¤‡å¥½æ¢ç´¢æ–°äº‹ç‰©ã€‚",
      "tags": ["ç²¾åŠ›å……æ²›", "å†’é™©", "çµæ´»"],
      "compatibility": ["ESFP", "ISTP"]
    },
    "ESFP": {
      "name": "æ´¾å¯¹ä¹‹æ˜Ÿ",
      "description": "æ´»æ³¼ã€æœ‰è¶£çš„ç‹—ç‹—ï¼Œæ€»èƒ½æˆä¸ºæ³¨æ„åŠ›çš„ä¸­å¿ƒã€‚",
      "tags": ["æ´»æ³¼", "æœ‰è¶£", "çˆ±ç©"],
      "compatibility": ["ESTP", "ISFP"]
    },
    "ISTP": {
      "name": "ç‹¬è¡Œä¾ ",
      "description": "ç‹¬ç«‹ã€å†·é™çš„ç‹—ç‹—ï¼Œå–œæ¬¢è‡ªå·±æ¢ç´¢ï¼Œä¸è¿‡åˆ†ä¾èµ–ä»–äººã€‚",
      "tags": ["ç‹¬ç«‹", "å†·é™", "å¥½å¥‡"],
      "compatibility": ["ESTP", "ISFP"]
    },
    "ISFP": {
      "name": "æ¸©æŸ”è‰ºæœ¯å®¶",
      "description": "æ¸©å’Œã€æ•æ„Ÿçš„ç‹—ç‹—ï¼Œç”¨è‡ªå·±çš„æ–¹å¼æ„Ÿå—ä¸–ç•Œã€‚",
      "tags": ["æ¸©å’Œ", "æ•æ„Ÿ", "è‰ºæœ¯"],
      "compatibility": ["ESFP", "ISTP"]
    },
    "ENTJ": {
      "name": "æŒ‡æŒ¥å®˜",
      "description": "è‡ªä¿¡ã€æœæ–­çš„ç‹—ç‹—ï¼Œå–œæ¬¢æŒæ§å±€é¢ï¼Œæ˜¯å¤©ç”Ÿçš„é¢†å¯¼è€…ã€‚",
      "tags": ["è‡ªä¿¡", "æœæ–­", "é¢†å¯¼åŠ›"],
      "compatibility": ["ENTJ", "INTJ"]
    },
    "ENTP": {
      "name": "è¾©è®ºå®¶",
      "description": "èªæ˜ã€å¥½å¥‡çš„ç‹—ç‹—ï¼Œæ€»æ˜¯å¯»æ‰¾æ–°çš„æŒ‘æˆ˜å’Œæ¸¸æˆã€‚",
      "tags": ["èªæ˜", "å¥½å¥‡", "åˆ›æ„"],
      "compatibility": ["ENTP", "INTP"]
    },
    "INTJ": {
      "name": "ç­–åˆ’å¸ˆ",
      "description": "ç‹¬ç«‹ã€æ™ºæ…§çš„ç‹—ç‹—ï¼Œå–œæ¬¢æ€è€ƒåè¡ŒåŠ¨ã€‚",
      "tags": ["ç‹¬ç«‹", "æ™ºæ…§", "ç­–ç•¥"],
      "compatibility": ["ENTJ", "INTJ"]
    },
    "INTP": {
      "name": "é€»è¾‘å­¦å®¶",
      "description": "å¥½å¥‡ã€åˆ†æçš„ç‹—ç‹—ï¼Œå–œæ¬¢æ¢ç´¢å’Œç†è§£å‘¨å›´ç¯å¢ƒã€‚",
      "tags": ["å¥½å¥‡", "åˆ†æ", "åˆ›æ–°"],
      "compatibility": ["ENTP", "INTP"]
    },
    "ENFJ": {
      "name": "å¯¼å¸ˆ",
      "description": "å¯Œæœ‰åŒç†å¿ƒã€é¼“èˆäººå¿ƒçš„ç‹—ç‹—ï¼Œèƒ½å¤Ÿæ„ŸçŸ¥å¹¶å½±å“ä»–äººçš„æƒ…ç»ªã€‚",
      "tags": ["åŒç†å¿ƒ", "é¼“èˆ", "é¢†å¯¼"],
      "compatibility": ["ENFJ", "INFJ"]
    },
    "ENFP": {
      "name": "ç«é€‰è€…",
      "description": "çƒ­æƒ…ã€æœ‰æƒ³è±¡åŠ›çš„ç‹—ç‹—ï¼Œæ€»æ˜¯å……æ»¡æ´»åŠ›å’Œåˆ›é€ åŠ›ã€‚",
      "tags": ["çƒ­æƒ…", "æƒ³è±¡", "è‡ªç”±"],
      "compatibility": ["ENFP", "INFP"]
    },
    "INFJ": {
      "name": "é¡¾é—®",
      "description": "ç¥ç§˜ã€æ·±åˆ»ç†è§£çš„ç‹—ç‹—ï¼Œä¼¼ä¹èƒ½çœ‹é€äººå¿ƒã€‚",
      "tags": ["ç¥ç§˜", "æ·±åˆ»", "ç›´è§‰"],
      "compatibility": ["ENFJ", "INFJ"]
    },
    "INFP": {
      "name": "æ²»æ„ˆè€…",
      "description": "ç†æƒ³ä¸»ä¹‰ã€æ¸©æŸ”çš„ç‹—ç‹—ï¼Œå¯¹ä¸–ç•Œæœ‰ç‹¬ç‰¹çš„ç†è§£ã€‚",
      "tags": ["ç†æƒ³", "æ¸©æŸ”", "ç‹¬ç‰¹"],
      "compatibility": ["ENFP", "INFP"]
    }
  }
}
```

**Step 3: åˆ›å»º MBTI æœåŠ¡**

```python
# server/app/services/mbti_service.py
import json
from pathlib import Path

class MBTIService:
    def __init__(self):
        with open(Path(__file__).parent.parent / "data" / "mbti_questions.json") as f:
            self.questions = json.load(f)["questions"]
        with open(Path(__file__).parent.parent / "data" / "mbti_results.json") as f:
            self.results = json.load(f)["types"]

    def get_questions(self) -> list:
        """è·å–æ‰€æœ‰æµ‹è¯•é¢˜"""
        return self.questions

    def calculate_result(self, answers: dict[int, str]) -> dict:
        """è®¡ç®— MBTI ç»“æœ

        Args:
            answers: {question_id: selected_value}
        """
        scores = {"E": 0, "I": 0, "S": 0, "N": 0, "T": 0, "F": 0, "J": 0, "P": 0}

        for q_id, answer in answers.items():
            question = next((q for q in self.questions if q["id"] == q_id), None)
            if question:
                dimension = question["dimension"]
                scores[answer] += 1

        # ç¡®å®šæ¯ä¸ªç»´åº¦çš„ç»“æœ
        mbti = ""
        mbti += "E" if scores["E"] >= scores["I"] else "I"
        mbti += "S" if scores["S"] >= scores["N"] else "N"
        mbti += "T" if scores["T"] >= scores["F"] else "F"
        mbti += "J" if scores["J"] >= scores["P"] else "P"

        return {
            "mbti": mbti,
            "scores": scores,
            "detail": self.results[mbti]
        }

    def get_compatibility(self, mbti1: str, mbti2: str) -> str:
        """è·å–ä¸¤ä¸ª MBTI ç±»å‹çš„åŒ¹é…åº¦"""
        result1 = self.results.get(mbti1, {})
        compatible_types = result1.get("compatibility", [])

        if mbti2 in compatible_types:
            return "high"
        elif mbti1 == mbti2:
            return "medium"
        else:
            return "low"


mbti_service = MBTIService()
```

**Step 4: æäº¤**

```bash
mkdir -p server/app/data
git add server/app/data/mbti_questions.json server/app/data/mbti_results.json server/app/services/mbti_service.py
git commit -m "feat: add MBTI test data and service"
```

---

## Task 2: åç«¯ MBTI API

**Files:**
- Create: `server/app/schemas/mbti.py` - MBTI Schema
- Create: `server/app/api/v1/mbti.py` - MBTI è·¯ç”±

**Step 1: åˆ›å»º MBTI Schema**

```python
# server/app/schemas/mbti.py
from pydantic import BaseModel
from typing import Dict

class QuestionOption(BaseModel):
    text: str
    value: str

class Question(BaseModel):
    id: int
    dimension: str  # E/I, S/N, T/F, J/P
    question: str
    options: list[QuestionOption]

class MBTIAnswer(BaseModel):
    answers: dict[int, str]  # {question_id: selected_value}

class MBTIResult(BaseModel):
    mbti: str
    scores: dict[str, int]
    detail: dict
```

**Step 2: åˆ›å»º MBTI è·¯ç”±**

```python
# server/app/api/v1/mbti.py
from fastapi import APIRouter
from app.services.mbti_service import mbti_service
from app.schemas.mbti import Question, MBTIAnswer, MBTIResult

router = APIRouter(prefix="/mbti", tags=["MBTI"])

@router.get("/questions", response_model=list[Question])
async def get_questions():
    """è·å– MBTI æµ‹è¯•é¢˜"""
    return mbti_service.get_questions()

@router.post("/result", response_model=MBTIResult)
async def calculate_result(data: MBTIAnswer):
    """æäº¤ç­”æ¡ˆï¼Œè·å– MBTI ç»“æœ"""
    return mbti_service.calculate_result(data.answers)

@router.get("/compatibility/{mbti1}/{mbti2}")
async def get_compatibility(mbti1: str, mbti2: str):
    """è·å–ä¸¤ä¸ª MBTI ç±»å‹çš„åŒ¹é…åº¦"""
    return {
        "mbti1": mbti1,
        "mbti2": mbti2,
        "level": mbti_service.get_compatibility(mbti1, mbti2)
    }
```

**Step 3: æäº¤**

```bash
git add server/app/schemas/mbti.py server/app/api/v1/mbti.py
git commit -m "feat: add MBTI API"
```

---

## Task 3: å‰ç«¯ MBTI API æœåŠ¡

**Files:**
- Create: `apps/src/services/mbti.ts` - MBTI API

**Step 1: åˆ›å»º MBTI API**

```typescript
// apps/src/services/mbti.ts
import api from './api';

export interface Question {
  id: number;
  dimension: string;
  question: string;
  options: { text: string; value: string }[];
}

export interface MBTIResult {
  mbti: string;
  scores: Record<string, number>;
  detail: {
    name: string;
    description: string;
    tags: string[];
    compatibility: string[];
  };
}

export const mbtiService = {
  getQuestions: () => api.get<Question[]>('/mbti/questions'),

  submitAnswers: (answers: Record<number, string>) =>
    api.post<MBTIResult>('/mbti/result', { answers }),

  getCompatibility: (mbti1: string, mbti2: string) =>
    api.get(`/mbti/compatibility/${mbti1}/${mbti2}`),
};
```

**Step 2: æäº¤**

```bash
git add apps/src/services/mbti.ts
git commit -m "feat: add MBTI API service"
```

---

## Task 4: å‰ç«¯ MBTI æµ‹è¯•é¡µé¢

**Files:**
- Create: `apps/src/screens/mbti/MBTIIntroScreen.tsx` - æµ‹è¯•ä»‹ç»é¡µ
- Create: `apps/src/screens/mbti/MBTITestScreen.tsx` - æµ‹è¯•ç­”é¢˜é¡µ
- Create: `apps/src/screens/mbti/MBTIResultScreen.tsx` - ç»“æœå±•ç¤ºé¡µ
- Create: `apps/src/components/MBTITypeCard.tsx` - MBTI ç±»å‹å¡ç‰‡

**Step 1: åˆ›å»ºæµ‹è¯•ä»‹ç»é¡µ**

```typescript
// apps/src/screens/mbti/MBTIIntroScreen.tsx
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';

export default function MBTIIntroScreen({ navigation, route }: any) {
  const { dogId } = route.params;

  return (
    <View style={styles.container}>
      <Text style={styles.emoji}>ğŸ•</Text>
      <Text style={styles.title}>ç‹—ç‹—æ€§æ ¼æµ‹è¯•</Text>
      <Text style={styles.description}>
        é€šè¿‡ 20 é“ç²¾å¿ƒè®¾è®¡çš„é¢˜ç›®ï¼Œå‘ç°ä½ å®¶ç‹—ç‹—ç‹¬ç‰¹çš„æ€§æ ¼ç±»å‹ã€‚
      </Text>

      <View style={styles.features}>
        <View style={styles.feature}>
          <Text style={styles.featureEmoji}>ğŸ§ </Text>
          <Text style={styles.featureText}>ç§‘å­¦åˆ†æ</Text>
        </View>
        <View style={styles.feature}>
          <Text style={styles.featureEmoji}>ğŸ¯</Text>
          <Text style={styles.featureText}>ç²¾å‡†åŒ¹é…</Text>
        </View>
        <View style={styles.feature}>
          <Text style={styles.featureEmoji}>ğŸ“Š</Text>
          <Text style={styles.featureText}>è¯¦ç»†æŠ¥å‘Š</Text>
        </View>
      </View>

      <TouchableOpacity
        style={styles.button}
        onPress={() => navigation.navigate('MBTITest', { dogId })}
      >
        <Text style={styles.buttonText}>å¼€å§‹æµ‹è¯•</Text>
      </TouchableOpacity>
    </View>
  );
}
```

**Step 2: åˆ›å»ºæµ‹è¯•ç­”é¢˜é¡µ**

```typescript
// apps/src/screens/mbti/MBTITestScreen.tsx
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, ProgressBarAndroid } from 'react-native';
import { mbtiService } from '@/services/mbti';

export default function MBTITestScreen({ navigation, route }: any) {
  const { dogId } = route.params;
  const [questions, setQuestions] = useState<Question[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [answers, setAnswers] = useState<Record<number, string>>({});

  useEffect(() => {
    loadQuestions();
  }, []);

  const loadQuestions = async () => {
    const res = await mbtiService.getQuestions();
    setQuestions(res.data);
  };

  const handleAnswer = (value: string) => {
    const newAnswers = { ...answers, [questions[currentIndex].id]: value };
    setAnswers(newAnswers);

    if (currentIndex < questions.length - 1) {
      setCurrentIndex(currentIndex + 1);
    } else {
      // æäº¤ç­”æ¡ˆ
      submitResult(newAnswers);
    }
  };

  const submitResult = async (finalAnswers: Record<number, string>) => {
    const res = await mbtiService.submitAnswers(finalAnswers);
    navigation.replace('MBTIResult', { dogId, result: res.data });
  };

  const progress = (currentIndex + 1) / questions.length;

  if (questions.length === 0) return <View><Text>åŠ è½½ä¸­...</Text></View>;

  const question = questions[currentIndex];

  return (
    <View style={styles.container}>
      <View style={styles.progressContainer}>
        <Text style={styles.progressText}>{currentIndex + 1}/{questions.length}</Text>
        <ProgressBarAndroid
          styleAttr="Horizontal"
          progress={progress}
          indeterminate={false}
          style={styles.progressBar}
        />
      </View>

      <View style={styles.questionContainer}>
        <Text style={styles.question}>{question.question}</Text>

        <View style={styles.options}>
          {question.options.map((option) => (
            <TouchableOpacity
              key={option.value}
              style={styles.option}
              onPress={() => handleAnswer(option.value)}
            >
              <Text style={styles.optionText}>{option.text}</Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>
    </View>
  );
}
```

**Step 3: åˆ›å»ºç»“æœå±•ç¤ºé¡µ**

```typescript
// apps/src/screens/mbti/MBTIResultScreen.tsx
import React, { useEffect } from 'react';
import { View, Text, ScrollView, TouchableOpacity, StyleSheet, Image } from 'react-native';
import { useDogStore } from '@/stores/dogStore';

export default function MBTIResultScreen({ navigation, route }: any) {
  const { dogId, result } = route.params;
  const { updateDog } = useDogStore();

  useEffect(() => {
    // ä¿å­˜ MBTI ç»“æœåˆ°ç‹—ç‹—æ¡£æ¡ˆ
    updateDog(dogId, { mbti: result.mbti });
  }, []);

  const handleShare = () => {
    // åˆ†äº«åŠŸèƒ½
  };

  return (
    <ScrollView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.emoji}>{getMBTIEmoji(result.mbti)}</Text>
        <Text style={styles.mbti}>{result.mbti}</Text>
        <Text style={styles.name}>{result.detail.name}</Text>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>æ€§æ ¼æè¿°</Text>
        <Text style={styles.description}>{result.detail.description}</Text>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>æ€§æ ¼æ ‡ç­¾</Text>
        <View style={styles.tags}>
          {result.detail.tags.map((tag, i) => (
            <View key={i} style={styles.tag}>
              <Text style={styles.tagText}>{tag}</Text>
            </View>
          ))}
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>å„ç»´åº¦å¾—åˆ†</Text>
        <View style={styles.scores}>
          {Object.entries(result.scores).map(([dim, score]) => (
            <View key={dim} style={styles.scoreItem}>
              <Text style={styles.dimLabel}>{dim}</Text>
              <View style={styles.scoreBar}>
                <View style={[styles.scoreFill, { width: `${score * 20}%` }]} />
              </View>
              <Text style={styles.scoreValue}>{score}</Text>
            </View>
          ))}
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>åŒ¹é…ç©ä¼´</Text>
        <Text style={styles.compatibilityText}>
          ä¸ {result.detail.compatibility.join('ã€')} ç±»å‹æœ€åˆæ‹ï¼
        </Text>
      </View>

      <TouchableOpacity style={styles.shareButton} onPress={handleShare}>
        <Text style={styles.shareButtonText}>åˆ†äº«ç»“æœ</Text>
      </TouchableOpacity>

      <TouchableOpacity
        style={styles.doneButton}
        onPress={() => navigation.goBack()}
      >
        <Text style={styles.doneButtonText}>å®Œæˆ</Text>
      </TouchableOpacity>
    </ScrollView>
  );
}

function getMBTIEmoji(mbti: string): string {
  const emojiMap: Record<string, string> = {
    'ESTJ': 'ğŸ‘®', 'ESFJ': 'ğŸ¦‹', 'ISTJ': 'ğŸ›¡ï¸', 'ISFJ': 'ğŸ’',
    'ESTP': 'ğŸƒ', 'ESFP': 'ğŸ‰', 'ISTP': 'ğŸ•µï¸', 'ISFP': 'ğŸ¨',
    'ENTJ': 'ğŸ‘‘', 'ENTP': 'ğŸ’¡', 'INTJ': 'ğŸ”®', 'INTP': 'ğŸ”¬',
    'ENFJ': 'ğŸ¤', 'ENFP': 'ğŸŒˆ', 'INFJ': 'ğŸŒ™', 'INFP': 'ğŸŒ¸',
  };
  return emojiMap[mbti] || 'ğŸ•';
}
```

**Step 4: åˆ›å»º MBTI ç±»å‹å¡ç‰‡ç»„ä»¶**

```typescript
// apps/src/components/MBTITypeCard.tsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

interface MBTITypeCardProps {
  mbti: string;
  name?: string;
  size?: 'small' | 'medium' | 'large';
}

export default function MBTITypeCard({ mbti, name, size = 'medium' }: MBTITypeCardProps) {
  return (
    <View style={[styles.container, styles[size]]}>
      <View style={styles.badge}>
        <Text style={[styles.mbti, styles[`mbti${size}`]]}>{mbti}</Text>
      </View>
      {name && <Text style={styles.name}>{name}</Text>}
    </View>
  );
}
```

**Step 5: æäº¤**

```bash
git add apps/src/screens/mbti/ apps/src/components/MBTITypeCard.tsx
git commit -m "feat: add MBTI test screens and components"
```

---

## Task 5: ç‹—ç‹—æ¡£æ¡ˆé›†æˆ MBTI

**Files:**
- Modify: `apps/src/screens/dogs/DogDetailScreen.tsx` - æ˜¾ç¤º MBTI
- Modify: `apps/src/components/DogCard.tsx` - æ˜¾ç¤º MBTI æ ‡ç­¾
- Modify: `apps/src/components/SessionCard.tsx` - æ˜¾ç¤º MBTI åŒ¹é…åº¦

**Step 1: æ›´æ–°ç‹—ç‹—è¯¦æƒ…é¡µ**

```typescript
// apps/src/screens/dogs/DogDetailScreen.tsx
// æ·»åŠ  MBTI æµ‹è¯•å…¥å£å’Œç»“æœå±•ç¤º
<View style={styles.mbtiSection}>
  {dog.mbti ? (
    <MBTITypeCard mbti={dog.mbti} />
  ) : (
    <TouchableOpacity onPress={() => navigation.navigate('MBTIIntro', { dogId: dog.id })}>
      <Text>ğŸ“ æµ‹æµ‹ TA çš„æ€§æ ¼</Text>
    </TouchableOpacity>
  )}
</View>
```

**Step 2: æäº¤**

```bash
git add apps/src/screens/dogs/DogDetailScreen.tsx
git commit -m "feat: integrate MBTI into dog profile"
```

---

## å®Œæˆæ£€æŸ¥

**åç«¯æ£€æŸ¥:**
```bash
# è·å–æµ‹è¯•é¢˜
curl http://localhost:8000/api/v1/mbti/questions

# æäº¤ç­”æ¡ˆ
curl -X POST http://localhost:8000/api/v1/mbti/result \
  -d '{"answers":{"1":"E","2":"S","3":"T","4":"J"}}'
```

**å‰ç«¯æ£€æŸ¥:**
- [ ] æµ‹è¯•é¢˜æ­£å¸¸æ˜¾ç¤º
- [ ] ç­”é¢˜æµç¨‹æµç•…
- [ ] ç»“æœå±•ç¤ºå®Œæ•´
- [ ] MBTI ä¿å­˜åˆ°ç‹—ç‹—æ¡£æ¡ˆ
- [ ] MBTI æ ‡ç­¾åœ¨å¡ç‰‡ä¸Šæ˜¾ç¤º

**é˜¶æ®µäº”éªŒæ”¶æ ‡å‡†:**
- [ ] 20 é“æµ‹è¯•é¢˜è¦†ç›–å››ä¸ªç»´åº¦
- [ ] ç­”é¢˜è¿‡ç¨‹æµç•…
- [ ] ç»“æœå±•ç¤ºåŒ…å«ç±»å‹åç§°ã€æè¿°ã€æ ‡ç­¾ã€å¾—åˆ†
- [ ] MBTI ç»“æœä¿å­˜åˆ°æ•°æ®åº“
- [ ] åœ¨ç‹—ç‹—æ¡£æ¡ˆå’Œèšä¼šå¡ç‰‡ä¸­æ˜¾ç¤º MBTI
