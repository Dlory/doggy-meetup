# é˜¶æ®µå››ï¼šå°ç»„èŠå¤© Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** å®ç°ä¸´æ—¶é›ç‹—å°ç»„çš„èŠå¤©åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ–‡å­—ã€è¯­éŸ³ã€ä½ç½®æ¶ˆæ¯

**Duration:** 4-5å¤©

**Tech Stack:** WebSocket, FastAPI, React Native, expo-av

**Reference:** `docs/designs/2025-01-28-doggy-meetup-design.md` ç¬¬2.4èŠ‚

---

## Task 1: åç«¯ WebSocket è¿æ¥

**Files:**
- Create: `server/app/api/v1/websocket.py` - WebSocket è·¯ç”±
- Create: `server/app/services/websocket_manager.py` - WebSocket è¿æ¥ç®¡ç†

**Step 1: åˆ›å»º WebSocket ç®¡ç†å™¨**

```python
# server/app/services/websocket_manager.py
from typing import Dict, Set
from fastapi import WebSocket
import json

class ConnectionManager:
    def __init__(self):
        # group_id -> set of websocket connections
        self.active_connections: Dict[str, Set[WebSocket]] = {}
        # user_id -> websocket
        self.user_connections: Dict[str, WebSocket] = {}

    async def connect(self, websocket: WebSocket, user_id: str):
        await websocket.accept()
        self.user_connections[user_id] = websocket

    def disconnect(self, user_id: str):
        if user_id in self.user_connections:
            del self.user_connections[user_id]
        # ç§»é™¤ç”¨æˆ·åœ¨æ‰€æœ‰ç¾¤ç»„ä¸­çš„è¿æ¥
        for group_id in list(self.active_connections.keys()):
            self.remove_from_group(group_id, user_id)

    def add_to_group(self, group_id: str, user_id: str):
        if group_id not in self.active_connections:
            self.active_connections[group_id] = set()
        ws = self.user_connections.get(user_id)
        if ws:
            self.active_connections[group_id].add(ws)

    def remove_from_group(self, group_id: str, user_id: str):
        if group_id in self.active_connections:
            ws = self.user_connections.get(user_id)
            if ws and ws in self.active_connections[group_id]:
                self.active_connections[group_id].remove(ws)

    async def send_to_group(self, group_id: str, message: dict):
        if group_id in self.active_connections:
            for connection in self.active_connections[group_id]:
                await connection.send_json(message)

    async def send_to_user(self, user_id: str, message: dict):
        ws = self.user_connections.get(user_id)
        if ws:
            await ws.send_json(message)

    async def broadcast(self, message: dict):
        for connection in self.user_connections.values():
            await connection.send_json(message)


manager = ConnectionManager()
```

**Step 2: åˆ›å»º WebSocket è·¯ç”±**

```python
# server/app/api/v1/websocket.py
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Query
from app.services.websocket_manager import manager
import json

router = APIRouter()

@router.websocket("/ws")
async def websocket_endpoint(
    websocket: WebSocket,
    token: str = Query(...),
    user_id: str = Query(...)
):
    # éªŒè¯ token
    await manager.connect(websocket, user_id)

    try:
        while True:
            data = await websocket.receive_json()
            msg_type = data.get("type")

            if msg_type == "ping":
                await websocket.send_json({"type": "pong"})

            elif msg_type == "join_group":
                group_id = data.get("group_id")
                manager.add_to_group(group_id, user_id)

            elif msg_type == "leave_group":
                group_id = data.get("group_id")
                manager.remove_from_group(group_id, user_id)

            elif msg_type == "send_message":
                group_id = data.get("group_id")
                content = data.get("content")
                message_type = data.get("message_type", "text")

                # ä¿å­˜æ¶ˆæ¯åˆ°æ•°æ®åº“
                # ...

                # å¹¿æ’­æ¶ˆæ¯
                await manager.send_to_group(group_id, {
                    "type": "new_message",
                    "group_id": group_id,
                    "message": {
                        "user_id": user_id,
                        "content": content,
                        "message_type": message_type,
                    }
                })

            elif msg_type == "share_location":
                group_id = data.get("group_id")
                await manager.send_to_group(group_id, {
                    "type": "location_shared",
                    "group_id": group_id,
                    "user_id": user_id,
                    "latitude": data.get("latitude"),
                    "longitude": data.get("longitude"),
                })

    except WebSocketDisconnect:
        manager.disconnect(user_id)
```

**Step 3: æ³¨å†Œ WebSocket è·¯ç”±**

```python
# server/app/main.py
from app.api.v1 import websocket

app.include_router(websocket.router)
```

**Step 4: æäº¤**

```bash
git add server/app/services/websocket_manager.py server/app/api/v1/websocket.py
git commit -m "feat: add WebSocket support"
```

---

## Task 2: åç«¯èŠå¤©ç»„ API

**Files:**
- Create: `server/app/schemas/chat.py` - èŠå¤© Schema
- Create: `server/app/services/chat_service.py` - èŠå¤©æœåŠ¡
- Create: `server/app/api/v1/groups.py` - å°ç»„è·¯ç”±

**Step 1: åˆ›å»ºèŠå¤© Schema**

```python
# server/app/schemas/chat.py
from pydantic import BaseModel
from uuid import UUID
from datetime import datetime

class ChatGroupResponse(BaseModel):
    id: UUID
    session_id: UUID
    name: str
    created_at: datetime

class ChatMessageBase(BaseModel):
    group_id: UUID
    content: str
    message_type: str = "text"  # text, voice, location, system

class ChatMessageResponse(ChatMessageBase):
    id: UUID
    user_id: UUID
    user_nickname: str
    user_avatar: str | None
    created_at: datetime
```

**Step 2: åˆ›å»ºèŠå¤©æœåŠ¡**

```python
# server/app/services/chat_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models.chat import ChatGroup, ChatMessage
from app.models.session import Session
from app.schemas.chat import ChatMessageResponse

class ChatService:
    async def get_or_create_group(
        self, db: AsyncSession, session_id: UUID
    ) -> ChatGroup:
        """è·å–æˆ–åˆ›å»ºèŠå¤©ç»„"""
        result = await db.execute(
            select(ChatGroup).where(ChatGroup.session_id == session_id)
        )
        group = result.scalar_one_or_none()

        if not group:
            # ä» session è·å–ä¿¡æ¯åˆ›å»ºç¾¤ç»„
            session = await db.get(Session, session_id)
            group = ChatGroup(
                session_id=session_id,
                name=f"{session.title}å°ç»„"
            )
            db.add(group)
            await db.commit()
            await db.refresh(group)

        return group

    async def get_messages(
        self, db: AsyncSession, group_id: UUID, limit: int = 50
    ) -> list[ChatMessage]:
        """è·å–èŠå¤©å†å²"""
        pass

    async def create_message(
        self, db: AsyncSession, group_id: UUID, user_id: UUID,
        content: str, message_type: str = "text"
    ) -> ChatMessage:
        """åˆ›å»ºæ¶ˆæ¯"""
        pass

    async def remove_member(
        self, db: AsyncSession, group_id: UUID, user_id: UUID, admin_id: UUID
    ) -> bool:
        """ç®¡ç†å‘˜ç§»é™¤æˆå‘˜"""
        pass
```

**Step 3: åˆ›å»ºå°ç»„è·¯ç”±**

```python
# server/app/api/v1/groups.py
from fastapi import APIRouter, Depends
from app.schemas.chat import ChatGroupResponse, ChatMessageResponse

router = APIRouter(prefix="/groups", tags=["å°ç»„"])

@router.get("", response_model=list[ChatGroupResponse])
async def get_my_groups():
    """è·å–æˆ‘çš„å°ç»„åˆ—è¡¨"""
    pass

@router.get("/{group_id}", response_model=ChatGroupResponse)
async def get_group(group_id: UUID):
    """è·å–å°ç»„è¯¦æƒ…"""
    pass

@router.get("/{group_id}/messages", response_model=list[ChatMessageResponse])
async def get_messages(group_id: UUID, limit: int = 50):
    """è·å–èŠå¤©å†å²"""
    pass

@router.post("/{group_id}/messages", response_model=ChatMessageResponse)
async def send_message(group_id: UUID, content: str, message_type: str = "text"):
    """å‘é€æ¶ˆæ¯ï¼ˆHTTP æ–¹å¼ï¼ŒWebSocket ä¼˜å…ˆï¼‰"""
    pass

@router.delete("/{group_id}/{user_id}")
async def remove_member(group_id: UUID, user_id: UUID):
    """ç§»é™¤æˆå‘˜ï¼ˆä»…ç®¡ç†å‘˜ï¼‰"""
    pass
```

**Step 4: æäº¤**

```bash
git add server/app/schemas/chat.py server/app/services/chat_service.py server/app/api/v1/groups.py
git commit -m "feat: add chat group API"
```

---

## Task 3: èšä¼šçŠ¶æ€è‡ªåŠ¨æµè½¬

**Files:**
- Modify: `server/app/services/session_service.py`

**Step 1: æ·»åŠ çŠ¶æ€æµè½¬é€»è¾‘**

```python
# server/app/services/session_service.py
from app.services.websocket_manager import manager
from app.services.chat_service import ChatService

class SessionService:
    async def join_session(self, db: AsyncSession, session_id: UUID, dog_id: UUID) -> Session:
        # ... åŸæœ‰é€»è¾‘ ...

        # æ£€æŸ¥æ˜¯å¦æ»¡å‘˜ï¼Œæ»¡å‘˜åˆ™åˆ›å»ºç¾¤ç»„
        session = await self.check_and_update_status(db, session)
        if session.status == SessionStatus.full and not session.chat_group_id:
            await self._create_chat_group_on_full(db, session)

        return session

    async def _create_chat_group_on_full(self, db: AsyncSession, session: Session):
        """æ»¡å‘˜æ—¶è‡ªåŠ¨åˆ›å»ºç¾¤ç»„"""
        chat_service = ChatService()
        group = await chat_service.get_or_create_group(db, session.id)

        session.chat_group_id = group.id
        session.status = SessionStatus.upcoming
        await db.commit()

        # é€šçŸ¥æ‰€æœ‰å‚ä¸è€…
        participants = await self.get_participants(db, session.id)
        for participant in participants:
            await manager.send_to_user(participant.user_id, {
                "type": "session_full",
                "session_id": str(session.id),
                "group_id": str(group.id),
                "title": "ğŸ‰ æ‹¼å›¢æˆåŠŸï¼",
                "body": f"ã€Œ{session.title}ã€å·²æ»¡å‘˜ï¼Œå°ç»„å·²åˆ›å»º",
            })

    async def start_early(self, db: AsyncSession, session_id: UUID, admin_id: UUID) -> Session:
        """ç®¡ç†å‘˜æå‰å¼€å§‹"""
        session = await db.get(Session, session_id)

        # éªŒè¯æ˜¯å‘èµ·äºº
        if session.creator_id != admin_id:
            raise HTTPException(403, "åªæœ‰å‘èµ·äººå¯ä»¥æå‰å¼€å§‹")

        # åˆ›å»ºç¾¤ç»„ï¼ˆå¦‚æœæ²¡æœ‰ï¼‰
        if not session.chat_group_id:
            await self._create_chat_group_on_full(db, session)

        session.status = SessionStatus.upcoming
        await db.commit()

        # é€šçŸ¥æ‰€æœ‰å‚ä¸è€…
        participants = await self.get_participants(db, session.id)
        for participant in participants:
            await manager.send_to_user(participant.user_id, {
                "type": "session_started",
                "session_id": str(session.id),
                "title": "ğŸš€ èšä¼šå·²å¼€å§‹",
                "body": f"ã€Œ{session.title}ã€å·²å¼€å§‹",
            })

        return session
```

**Step 2: æäº¤**

```bash
git add server/app/services/session_service.py
git commit -m "feat: add auto chat group creation on session full"
```

---

## Task 4: å‰ç«¯ WebSocket æœåŠ¡

**Files:**
- Create: `apps/src/services/websocket.ts` - WebSocket å®¢æˆ·ç«¯
- Create: `apps/src/stores/websocketStore.ts` - WebSocket çŠ¶æ€

**Step 1: åˆ›å»º WebSocket å®¢æˆ·ç«¯**

```typescript
// apps/src/services/websocket.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import config from '@/config';

class WebSocketClient {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private listeners: Map<string, ((data: any) => void)[]> = new Map();

  connect() {
    const token = AsyncStorage.getItem('access_token');
    const userId = useAuthStore.getState().user?.id;

    const wsUrl = `${config.apiUrl.replace('http', 'ws')}/ws?token=${token}&user_id=${userId}`;

    this.ws = new WebSocket(wsUrl);

    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
    };

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      const listeners = this.listeners.get(data.type) || [];
      listeners.forEach((listener) => listener(data));
    };

    this.ws.onclose = () => {
      console.log('WebSocket disconnected');
      this.reconnect();
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }

  reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      setTimeout(() => this.connect(), 1000 * this.reconnectAttempts);
    }
  }

  send(data: any) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }

  on(eventType: string, callback: (data: any) => void) {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType)!.push(callback);
  }

  off(eventType: string, callback: (data: any) => void) {
    const listeners = this.listeners.get(eventType);
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  joinGroup(groupId: string) {
    this.send({ type: 'join_group', group_id: groupId });
  }

  leaveGroup(groupId: string) {
    this.send({ type: 'leave_group', group_id: groupId });
  }

  sendMessage(groupId: string, content: string, messageType = 'text') {
    this.send({
      type: 'send_message',
      group_id: groupId,
      content,
      message_type: messageType,
    });
  }

  shareLocation(groupId: string, latitude: number, longitude: number) {
    this.send({
      type: 'share_location',
      group_id: groupId,
      latitude,
      longitude,
    });
  }

  disconnect() {
    this.ws?.close();
    this.reconnectAttempts = this.maxReconnectAttempts;
  }
}

export const wsClient = new WebSocketClient();
```

**Step 2: åˆ›å»º WebSocket Store**

```typescript
// apps/src/stores/websocketStore.ts
import { create } from 'zustand';
import { wsClient } from '@/services/websocket';

interface WebSocketState {
  connected: boolean;
  currentGroup: string | null;
  messages: ChatMessage[];
  notifications: Notification[];
  connect: () => void;
  joinGroup: (groupId: string) => void;
  leaveGroup: () => void;
  sendMessage: (content: string, type?: string) => void;
  shareLocation: (lat: number, lng: number) => void;
}

export const useWebSocketStore = create<WebSocketState>((set, get) => ({
  connected: false,
  currentGroup: null,
  messages: [],
  notifications: [],

  connect: () => {
    wsClient.on('open', () => set({ connected: true }));
    wsClient.on('close', () => set({ connected: false, currentGroup: null }));
    wsClient.on('new_message', (data) => {
      if (data.group_id === get().currentGroup) {
        set((state) => ({ messages: [...state.messages, data.message] }));
      }
    });
    wsClient.on('session_full', (data) => {
      set((state) => ({ notifications: [...state.notifications, data] }));
    });
    wsClient.connect();
  },

  joinGroup: (groupId) => {
    wsClient.joinGroup(groupId);
    set({ currentGroup: groupId, messages: [] });
  },

  leaveGroup: () => {
    const { currentGroup } = get();
    if (currentGroup) {
      wsClient.leaveGroup(currentGroup);
      set({ currentGroup: null, messages: [] });
    }
  },

  sendMessage: (content, type = 'text') => {
    const { currentGroup } = get();
    if (currentGroup) {
      wsClient.sendMessage(currentGroup, content, type);
    }
  },

  shareLocation: (lat, lng) => {
    const { currentGroup } = get();
    if (currentGroup) {
      wsClient.shareLocation(currentGroup, lat, lng);
    }
  },
}));
```

**Step 3: æäº¤**

```bash
git add apps/src/services/websocket.ts apps/src/stores/websocketStore.ts
git commit -m "feat: add WebSocket client and store"
```

---

## Task 5: å°ç»„èŠå¤©é¡µé¢ UI

**Files:**
- Create: `apps/src/screens/chat/ChatScreen.tsx` - èŠå¤©é¡µé¢
- Create: `apps/src/screens/chat/GroupsScreen.tsx` - æˆ‘çš„å°ç»„åˆ—è¡¨
- Create: `apps/src/components/ChatBubble.tsx` - æ¶ˆæ¯æ°”æ³¡
- Create: `apps/src/components/MessageInput.tsx` - æ¶ˆæ¯è¾“å…¥æ¡†

**Step 1: åˆ›å»ºæ¶ˆæ¯æ°”æ³¡ç»„ä»¶**

```typescript
// apps/src/components/ChatBubble.tsx
import React from 'react';
import { View, Text, Image, StyleSheet } from 'react-native';

interface ChatBubbleProps {
  message: ChatMessage;
  isOwn: boolean;
}

export default function ChatBubble({ message, isOwn }: ChatBubbleProps) {
  if (message.message_type === 'location') {
    return (
      <View style={[styles.container, isOwn ? styles.own : styles.other]}>
        <Text style={styles.locationText}>ğŸ“ å…±äº«äº†ä½ç½®</Text>
        <Text style={styles.coordinate}>{message.content}</Text>
      </View>
    );
  }

  if (message.message_type === 'voice') {
    return (
      <View style={[styles.container, isOwn ? styles.own : styles.other]}>
        <Text style={styles.text}>ğŸ¤ è¯­éŸ³æ¶ˆæ¯</Text>
        <Text style={styles.duration}>{message.duration}"</Text>
      </View>
    );
  }

  if (message.message_type === 'system') {
    return (
      <View style={styles.systemContainer}>
        <Text style={styles.systemText}>{message.content}</Text>
      </View>
    );
  }

  return (
    <View style={[styles.container, isOwn ? styles.own : styles.other]}>
      {!isOwn && <Text style={styles.sender}>{message.user_nickname}</Text>}
      <View style={[styles.bubble, isOwn ? styles.ownBubble : styles.otherBubble]}>
        <Text style={styles.text}>{message.content}</Text>
      </View>
      <Text style={styles.time}>{formatTime(message.created_at)}</Text>
    </View>
  );
}
```

**Step 2: åˆ›å»ºæ¶ˆæ¯è¾“å…¥æ¡†**

```typescript
// apps/src/components/MessageInput.tsx
import React, { useState } from 'react';
import { View, TextInput, TouchableOpacity, Text, StyleSheet } from 'react-native';
import * as Location from 'expo-location';

interface MessageInputProps {
  onSend: (content: string, type?: string) => void;
}

export default function MessageInput({ onSend }: MessageInputProps) {
  const [text, setText] = useState('');

  const handleSend = () => {
    if (text.trim()) {
      onSend(text.trim());
      setText('');
    }
  };

  const handleLocation = async () => {
    const loc = await Location.getCurrentPositionAsync({});
    onSend(
      `${loc.coords.latitude},${loc.coords.longitude}`,
      'location'
    );
  };

  return (
    <View style={styles.container}>
      <TouchableOpacity style={styles.iconButton} onPress={handleLocation}>
        <Text style={styles.icon}>ğŸ“</Text>
      </TouchableOpacity>

      <TextInput
        value={text}
        onChangeText={setText}
        placeholder="è¾“å…¥æ¶ˆæ¯..."
        style={styles.input}
      />

      <TouchableOpacity style={styles.iconButton} onPress={() => {}}>
        <Text style={styles.icon}>ğŸ¤</Text>
      </TouchableOpacity>

      <TouchableOpacity style={styles.sendButton} onPress={handleSend}>
        <Text style={styles.sendText}>å‘é€</Text>
      </TouchableOpacity>
    </View>
  );
}
```

**Step 3: åˆ›å»ºèŠå¤©é¡µé¢**

```typescript
// apps/src/screens/chat/ChatScreen.tsx
import React, { useEffect, useRef } from 'react';
import { View, FlatList, KeyboardAvoidingView, Platform, StyleSheet } from 'react-native';
import { useWebSocketStore } from '@/stores/websocketStore';
import { useAuthStore } from '@/stores/authStore';
import ChatBubble from '@/components/ChatBubble';
import MessageInput from '@/components/MessageInput';

export default function ChatScreen({ route }: any) {
  const { groupId } = route.params;
  const { messages, joinGroup, leaveGroup, sendMessage, connected } = useWebSocketStore();
  const currentUser = useAuthStore((s) => s.user);
  const flatListRef = useRef<FlatList>(null);

  useEffect(() => {
    joinGroup(groupId);
    return () => {
      leaveGroup();
    };
  }, [groupId]);

  useEffect(() => {
    // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
    flatListRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={90}
    >
      {!connected && <View style={styles.statusBar}><Text>è¿æ¥ä¸­...</Text></View>}

      <FlatList
        ref={flatListRef}
        data={messages}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <ChatBubble
            message={item}
            isOwn={item.user_id === currentUser?.id}
          />
        )}
        contentContainerStyle={styles.listContent}
      />

      <MessageInput onSend={sendMessage} />
    </KeyboardAvoidingView>
  );
}
```

**Step 4: åˆ›å»ºå°ç»„åˆ—è¡¨é¡µé¢**

```typescript
// apps/src/screens/chat/GroupsScreen.tsx
import React from 'react';
import { View, Text, FlatList, TouchableOpacity, StyleSheet } from 'react-native';

export default function GroupsScreen({ navigation }: any) {
  const groups = [
    // ä» Store è·å–
  ];

  return (
    <View style={styles.container}>
      <FlatList
        data={groups}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <TouchableOpacity
            style={styles.groupItem}
            onPress={() => navigation.navigate('Chat', { groupId: item.id })}
          >
            <View style={styles.avatar}>
              <Text style={styles.avatarText}>ğŸ•</Text>
            </View>
            <View style={styles.info}>
              <Text style={styles.name}>{item.name}</Text>
              <Text style={styles.lastMessage}>æŸ¥çœ‹èŠå¤©</Text>
            </View>
          </TouchableOpacity>
        )}
      />
    </View>
  );
}
```

**Step 5: æäº¤**

```bash
git add apps/src/screens/chat/ apps/src/components/ChatBubble.tsx apps/src/components/MessageInput.tsx
git commit -m "feat: add chat screens and components"
```

---

## Task 6: è¯­éŸ³æ¶ˆæ¯åŠŸèƒ½ï¼ˆå¯é€‰ï¼‰

**Files:**
- Modify: `apps/src/components/MessageInput.tsx`
- Create: `apps/src/utils/audioRecorder.ts`

**Step 1: åˆ›å»ºå½•éŸ³å·¥å…·**

```typescript
// apps/src/utils/audioRecorder.ts
import { Audio } from 'expo-av';

let recording: Audio.Recording | null = null;

export const startRecording = async () => {
  await Audio.requestPermissionsAsync();
  await Audio.setAudioModeAsync({
    allowsRecordingIOS: true,
    playsInSilentModeIOS: true,
  });

  recording = new Audio.Recording();
  await recording.prepareToRecordAsync(Audio.RECORDING_OPTIONS_PRESET_HIGH_QUALITY);
  await recording.startAsync();
};

export const stopRecording = async (): Promise<{ uri: string; duration: number }> => {
  if (!recording) return { uri: '', duration: 0 };

  await recording.stopAndUnloadAsync();
  const uri = recording.getURI();
  const status = await recording.getStatusAsync();

  recording = null;
  return { uri: uri || '', duration: Math.floor((status?.durationMillis || 0) / 1000) };
};
```

**Step 2: æ›´æ–°æ¶ˆæ¯è¾“å…¥æ¡†æ”¯æŒå½•éŸ³**

```typescript
// apps/src/components/MessageInput.tsx
import { startRecording, stopRecording } from '@/utils/audioRecorder';

// æ·»åŠ é•¿æŒ‰å½•éŸ³é€»è¾‘
const handleRecordIn = async () => {
  await startRecording();
};

const handleRecordOut = async () => {
  const { uri, duration } = await stopRecording();
  if (duration > 1) {
    // ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶ï¼Œç„¶åå‘é€æ¶ˆæ¯
    onSend(uri, 'voice');
  }
};
```

**Step 3: æäº¤**

```bash
git add apps/src/utils/audioRecorder.ts apps/src/components/MessageInput.tsx
git commit -m "feat: add voice message support"
```

---

## å®Œæˆæ£€æŸ¥

**åç«¯æ£€æŸ¥:**
```bash
# ä½¿ç”¨ websocat æµ‹è¯• WebSocket
websocat "ws://localhost:8000/api/v1/ws?token=xxx&user_id=xxx"

# å‘é€æµ‹è¯•æ¶ˆæ¯
{"type": "ping"}
{"type": "join_group", "group_id": "xxx"}
{"type": "send_message", "group_id": "xxx", "content": "ä½ å¥½"}
```

**å‰ç«¯æ£€æŸ¥:**
- [ ] WebSocket è¿æ¥æ­£å¸¸
- [ ] å¯ä»¥åŠ å…¥/ç¦»å¼€ç¾¤ç»„
- [ ] æ¶ˆæ¯æ”¶å‘æ­£å¸¸
- [ ] ä½ç½®å…±äº«åŠŸèƒ½æ­£å¸¸
- [ ] è¯­éŸ³æ¶ˆæ¯åŠŸèƒ½æ­£å¸¸ï¼ˆå¦‚å®ç°ï¼‰

**é˜¶æ®µå››éªŒæ”¶æ ‡å‡†:**
- [ ] æ»¡å‘˜è‡ªåŠ¨åˆ›å»ºèŠå¤©ç»„
- [ ] èŠå¤©æ¶ˆæ¯å®æ—¶åŒæ­¥
- [ ] æ”¯æŒæ–‡å­—ã€ä½ç½®æ¶ˆæ¯
- [ ] ç®¡ç†å‘˜å¯ç§»é™¤æˆå‘˜
- [ ] è¿æ¥æ–­å¼€åè‡ªåŠ¨é‡è¿
